/**
 * Generator for Promise-based service functions.
 *
 * This module generates Promise-based wrappers around the Effect-based
 * service functions, allowing usage in non-Effect environments.
 *
 * @since 1.0.0
 */
import type { DataModel, EntitySetModel, EntityTypeModel } from "../model/DataModel.js"
import type { ODataVersion } from "../parser/EdmxSchema.js"
import { getEditableTypeName, getIdTypeName, getServiceClassName } from "./NamingHelper.js"

/**
 * Version-specific imports and identifiers.
 */
interface VersionConfig {
  readonly runtimeType: string
  readonly runtimeImport: string
}

const V2_CONFIG: VersionConfig = {
  runtimeType: "ODataRuntime",
  runtimeImport: "type ODataRuntime"
}

const V4_CONFIG: VersionConfig = {
  runtimeType: "ODataV4Runtime",
  runtimeImport: "type ODataV4Runtime"
}

const getVersionConfig = (version: ODataVersion): VersionConfig => version === "V4" ? V4_CONFIG : V2_CONFIG

/**
 * Get the Promise service name (e.g., "ProductsServicePromise").
 */
export const getPromiseServiceName = (entitySetName: string): string => `${getServiceClassName(entitySetName)}Promise`

/**
 * Generated Promise service file.
 *
 * @since 1.0.0
 * @category types
 */
export interface GeneratedPromiseServiceFile {
  readonly fileName: string
  readonly content: string
}

/**
 * Result of Promise service generation.
 *
 * @since 1.0.0
 * @category types
 */
export interface PromiseServiceGenerationResult {
  readonly entityServices: ReadonlyArray<GeneratedPromiseServiceFile>
}

/**
 * Generate all Promise-based service function files.
 *
 * @since 1.0.0
 * @category generation
 */
export const generatePromiseServiceFns = (dataModel: DataModel): PromiseServiceGenerationResult => {
  const entityServices: Array<GeneratedPromiseServiceFile> = []

  // Generate individual Promise service files
  for (const entitySet of dataModel.entitySets.values()) {
    const entityType = dataModel.entityTypes.get(entitySet.entityTypeFqName)
    if (entityType) {
      const promiseServiceName = getPromiseServiceName(entitySet.name)
      entityServices.push({
        fileName: `${promiseServiceName}.ts`,
        content: generatePromiseServiceFile(entitySet, entityType, dataModel)
      })
    }
  }

  return { entityServices }
}

/**
 * Generate a single Promise service file.
 */
const generatePromiseServiceFile = (
  entitySet: EntitySetModel,
  entityType: EntityTypeModel,
  dataModel: DataModel
): string => {
  const lines: Array<string> = []
  const versionConfig = getVersionConfig(dataModel.version)
  const serviceClassName = getServiceClassName(entitySet.name)
  const promiseServiceName = getPromiseServiceName(entitySet.name)
  const entityName = entityType.name
  const idTypeName = getIdTypeName(entityName)
  const editableName = getEditableTypeName(entityName)
  const hasKeys = entityType.keys.length > 0

  // Header and imports
  lines.push(`/**`)
  lines.push(
    ` * Promise-based ${entityName} service functions for ${dataModel.serviceName} OData ${dataModel.version}.`
  )
  lines.push(` * Generated by odata-effect-gen.`)
  lines.push(` *`)
  lines.push(` * These functions wrap the Effect-based service functions for use in`)
  lines.push(` * non-Effect environments. They take a runtime as the first argument.`)
  lines.push(` *`)
  lines.push(` * @example`)
  lines.push(` * \`\`\`ts`)
  lines.push(
    ` * import { ${
      versionConfig.runtimeType.replace("OData", "createOData").replace("Runtime", "Runtime")
    } } from "@odata-effect/odata-effect-promise"`
  )
  lines.push(` * import { ${promiseServiceName} } from "@template/${dataModel.serviceName.toLowerCase()}-effect"`)
  lines.push(` *`)
  lines.push(
    ` * const runtime = ${versionConfig.runtimeType.replace("OData", "createOData").replace("Runtime", "Runtime")}({`
  )
  lines.push(` *   baseUrl: "https://server.com",`)
  lines.push(` *   servicePath: "/odata/${dataModel.version.toLowerCase()}/"`)
  lines.push(` * })`)
  lines.push(` *`)
  lines.push(` * const items = await ${promiseServiceName}.getAll(runtime)`)
  lines.push(` * await runtime.dispose()`)
  lines.push(` * \`\`\``)
  lines.push(` *`)
  lines.push(` * @since 1.0.0`)
  lines.push(` */`)
  lines.push(`import { ${versionConfig.runtimeImport} } from "@odata-effect/odata-effect-promise/Runtime"`)
  lines.push(`import * as ${serviceClassName} from "./${serviceClassName}"`)
  lines.push(``)

  // Import models (type-only since they're only used in type annotations)
  lines.push(`import type {`)
  lines.push(`  ${entityName},`)
  if (hasKeys) {
    lines.push(`  ${idTypeName},`)
  }
  lines.push(`  ${editableName}`)
  lines.push(`} from "./Models"`)
  lines.push(``)

  // Query options import (using subpath imports for tree-shaking)
  const queryOptionsType = dataModel.version === "V4" ? "ODataV4QueryOptions" : "ODataQueryOptions"
  const queryOptionsModule = dataModel.version === "V4" ? "ODataV4Client" : "ODataClient"
  lines.push(`import type { ${queryOptionsType} } from "@odata-effect/odata-effect/${queryOptionsModule}"`)
  lines.push(``)

  // Re-export runtime type for convenience
  lines.push(`// Re-export runtime type for convenience`)
  lines.push(`export type { ${versionConfig.runtimeType} } from "@odata-effect/odata-effect-promise/Runtime"`)
  lines.push(``)

  lines.push(`// ============================================================================`)
  lines.push(`// Promise-based Functions`)
  lines.push(`// ============================================================================`)
  lines.push(``)

  // getAll
  lines.push(`/**`)
  lines.push(` * Fetch all ${entityName} entities.`)
  lines.push(` *`)
  lines.push(` * @since 1.0.0`)
  lines.push(` * @category operations`)
  lines.push(` */`)
  lines.push(`export const getAll = (`)
  lines.push(`  runtime: ${versionConfig.runtimeType},`)
  lines.push(`  options?: ${queryOptionsType}`)
  lines.push(`): Promise<ReadonlyArray<${entityName}>> =>`)
  lines.push(`  runtime.runPromise(${serviceClassName}.getAll(options))`)
  lines.push(``)

  // getById (if entity has keys)
  if (hasKeys) {
    lines.push(`/**`)
    lines.push(` * Fetch a single ${entityName} by ID.`)
    lines.push(` *`)
    lines.push(` * @since 1.0.0`)
    lines.push(` * @category operations`)
    lines.push(` */`)
    lines.push(`export const getById = (`)
    lines.push(`  runtime: ${versionConfig.runtimeType},`)
    lines.push(`  id: ${idTypeName}`)
    lines.push(`): Promise<${entityName}> =>`)
    lines.push(`  runtime.runPromise(${serviceClassName}.getById(id))`)
    lines.push(``)
  }

  // create
  lines.push(`/**`)
  lines.push(` * Create a new ${entityName} entity.`)
  lines.push(` *`)
  lines.push(` * @since 1.0.0`)
  lines.push(` * @category operations`)
  lines.push(` */`)
  lines.push(`export const create = (`)
  lines.push(`  runtime: ${versionConfig.runtimeType},`)
  lines.push(`  entity: ${editableName}`)
  lines.push(`): Promise<${entityName}> =>`)
  lines.push(`  runtime.runPromise(${serviceClassName}.create(entity))`)
  lines.push(``)

  // update (if entity has keys)
  if (hasKeys) {
    lines.push(`/**`)
    lines.push(` * Update an existing ${entityName} entity.`)
    lines.push(` *`)
    lines.push(` * @since 1.0.0`)
    lines.push(` * @category operations`)
    lines.push(` */`)
    lines.push(`export const update = (`)
    lines.push(`  runtime: ${versionConfig.runtimeType},`)
    lines.push(`  id: ${idTypeName},`)
    lines.push(`  entity: Partial<${editableName}>`)
    lines.push(`): Promise<void> =>`)
    lines.push(`  runtime.runPromise(${serviceClassName}.update(id, entity))`)
    lines.push(``)

    // delete
    lines.push(`/**`)
    lines.push(` * Delete a ${entityName} entity.`)
    lines.push(` *`)
    lines.push(` * @since 1.0.0`)
    lines.push(` * @category operations`)
    lines.push(` */`)
    lines.push(`export const del = (`)
    lines.push(`  runtime: ${versionConfig.runtimeType},`)
    lines.push(`  id: ${idTypeName}`)
    lines.push(`): Promise<void> =>`)
    lines.push(`  runtime.runPromise(${serviceClassName}.del(id))`)
    lines.push(``)

    // Alias for nice naming
    lines.push(`// Alias for nice naming`)
    lines.push(`export { del as delete }`)
    lines.push(``)
  }

  return lines.join("\n")
}
