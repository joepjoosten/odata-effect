/**
 * Generator for index.ts - Public API exports.
 *
 * @since 1.0.0
 */
import type { DataModel } from "../model/DataModel.js"
import {
  getEditableTypeName,
  getIdTypeName,
  getQueryFactoryName,
  getQueryInstanceName,
  getQueryInterfaceName,
  getServiceClassName
} from "./NamingHelper.js"
import { getPromiseServiceName } from "./ServiceFnPromiseGenerator.js"

/**
 * Generate the index.ts file content.
 *
 * @since 1.0.0
 * @category generation
 */
export const generateIndex = (dataModel: DataModel): string => {
  const lines: Array<string> = []

  // Header
  lines.push(`/**`)
  lines.push(` * Effect-based OData client for ${dataModel.serviceName} service.`)
  lines.push(` * Generated by odata-effect-gen.`)
  lines.push(` *`)
  lines.push(` * @since 1.0.0`)
  lines.push(` */`)
  lines.push(``)

  // Models
  lines.push(`// Models`)
  lines.push(`export {`)

  const modelExports: Array<string> = []

  // Enums
  for (const enumType of dataModel.enumTypes.values()) {
    modelExports.push(enumType.name)
  }

  // Complex types
  for (const complexType of dataModel.complexTypes.values()) {
    modelExports.push(complexType.name)
    modelExports.push(getEditableTypeName(complexType.name))
  }

  // Entity types
  for (const entityType of dataModel.entityTypes.values()) {
    modelExports.push(entityType.name)
    if (entityType.keys.length > 0) {
      modelExports.push(getIdTypeName(entityType.name))
    }
    modelExports.push(getEditableTypeName(entityType.name))
  }

  for (let i = 0; i < modelExports.length; i++) {
    const isLast = i === modelExports.length - 1
    lines.push(`  ${modelExports[i]}${isLast ? "" : ","}`)
  }

  lines.push(`} from "./Models"`)
  lines.push(``)

  // Individual Entity Services (tree-shakable module namespace re-exports)
  lines.push(`// Individual Entity Services (tree-shakable)`)
  for (const entitySet of dataModel.entitySets.values()) {
    const serviceClassName = getServiceClassName(entitySet.name)
    lines.push(`export * as ${serviceClassName} from "./${serviceClassName}"`)
  }
  lines.push(``)

  // Promise-based Entity Services (for non-Effect environments)
  lines.push(`// Promise-based Entity Services (for non-Effect environments)`)
  for (const entitySet of dataModel.entitySets.values()) {
    const promiseServiceName = getPromiseServiceName(entitySet.name)
    lines.push(`export * as ${promiseServiceName} from "./${promiseServiceName}"`)
  }
  lines.push(``)

  // Query Models
  lines.push(`// Query Models`)
  lines.push(`export {`)

  const queryExports: Array<string> = []

  // Complex types
  for (const complexType of dataModel.complexTypes.values()) {
    queryExports.push(getQueryInstanceName(complexType.name))
    queryExports.push(`type ${getQueryInterfaceName(complexType.name)}`)
  }

  // Entity types
  for (const entityType of dataModel.entityTypes.values()) {
    queryExports.push(getQueryInstanceName(entityType.name))
    queryExports.push(`type ${getQueryInterfaceName(entityType.name)}`)
  }

  // Query factories for entity sets
  for (const entitySet of dataModel.entitySets.values()) {
    const entityType = dataModel.entityTypes.get(entitySet.entityTypeFqName)
    if (entityType) {
      queryExports.push(getQueryFactoryName(entityType.name))
    }
  }

  for (let i = 0; i < queryExports.length; i++) {
    const isLast = i === queryExports.length - 1
    lines.push(`  ${queryExports[i]}${isLast ? "" : ","}`)
  }

  lines.push(`} from "./QueryModels"`)

  return lines.join("\n")
}
