/**
 * Generator for index.ts - Public API exports.
 *
 * @since 1.0.0
 */
import type { DataModel } from "../model/DataModel.js"
import {
  getEditableTypeName,
  getIdTypeName,
  getQueryFactoryName,
  getQueryInstanceName,
  getQueryInterfaceName,
  getServiceClassName
} from "./NamingHelper.js"
import { getPathBuildersModuleName } from "./NavigationGenerator.js"
import { getOperationsModuleName } from "./OperationsGenerator.js"

/**
 * Generate the index.ts file content.
 *
 * @since 1.0.0
 * @category generation
 */
export const generateIndex = (dataModel: DataModel): string => {
  const lines: Array<string> = []

  // Header
  lines.push(`/**`)
  lines.push(` * Effect-based OData client for ${dataModel.serviceName} service.`)
  lines.push(` * Generated by odata-effect-gen.`)
  lines.push(` *`)
  lines.push(` * @since 1.0.0`)
  lines.push(` */`)
  lines.push(``)

  // Models
  lines.push(`// Models`)
  lines.push(`export {`)

  const modelExports: Array<string> = []

  // Enums
  for (const enumType of dataModel.enumTypes.values()) {
    modelExports.push(enumType.name)
  }

  // Complex types
  for (const complexType of dataModel.complexTypes.values()) {
    modelExports.push(complexType.name)
    modelExports.push(getEditableTypeName(complexType.name))
  }

  // Entity types
  for (const entityType of dataModel.entityTypes.values()) {
    modelExports.push(entityType.name)
    if (entityType.keys.length > 0) {
      modelExports.push(getIdTypeName(entityType.name))
    }
    modelExports.push(getEditableTypeName(entityType.name))
  }

  for (let i = 0; i < modelExports.length; i++) {
    const isLast = i === modelExports.length - 1
    lines.push(`  ${modelExports[i]}${isLast ? "" : ","}`)
  }

  lines.push(`} from "./Models"`)
  lines.push(``)

  // Entity Services (all in one file using crud factory)
  lines.push(`// Entity Services`)
  lines.push(`// Use toPromise(runtime) from PathBuilders to convert Effect to Promise`)
  lines.push(`export {`)
  const serviceExports: Array<string> = []
  for (const entitySet of dataModel.entitySets.values()) {
    serviceExports.push(getServiceClassName(entitySet.name))
  }
  // Also export types
  serviceExports.push(`type CrudError`)
  serviceExports.push(`type CrudContext`)
  serviceExports.push(`type CrudService`)
  for (let i = 0; i < serviceExports.length; i++) {
    const isLast = i === serviceExports.length - 1
    lines.push(`  ${serviceExports[i]}${isLast ? "" : ","}`)
  }
  lines.push(`} from "./Services"`)
  lines.push(``)

  // Operations (FunctionImports, Functions, Actions) - only if there are unbound operations
  const hasUnboundOperations = Array.from(dataModel.operations.values()).some((op) => !op.isBound)
  if (hasUnboundOperations) {
    lines.push(`// Operations (FunctionImports, Functions, Actions)`)
    const operationsModuleName = getOperationsModuleName()
    lines.push(`export * as ${operationsModuleName} from "./${operationsModuleName}"`)
    lines.push(``)
  }

  // Path Builders (tree-shakable navigation)
  lines.push(`// Path Builders (tree-shakable navigation)`)
  const pathBuildersModuleName = getPathBuildersModuleName()
  lines.push(`export * from "./${pathBuildersModuleName}"`)
  lines.push(``)

  // Query Models
  lines.push(`// Query Models`)
  lines.push(`export {`)

  const queryExports: Array<string> = []

  // Complex types
  for (const complexType of dataModel.complexTypes.values()) {
    queryExports.push(getQueryInstanceName(complexType.name))
    queryExports.push(`type ${getQueryInterfaceName(complexType.name)}`)
  }

  // Entity types
  for (const entityType of dataModel.entityTypes.values()) {
    queryExports.push(getQueryInstanceName(entityType.name))
    queryExports.push(`type ${getQueryInterfaceName(entityType.name)}`)
  }

  // Query factories for entity sets
  for (const entitySet of dataModel.entitySets.values()) {
    const entityType = dataModel.entityTypes.get(entitySet.entityTypeFqName)
    if (entityType) {
      queryExports.push(getQueryFactoryName(entityType.name))
    }
  }

  for (let i = 0; i < queryExports.length; i++) {
    const isLast = i === queryExports.length - 1
    lines.push(`  ${queryExports[i]}${isLast ? "" : ","}`)
  }

  lines.push(`} from "./QueryModels"`)

  return lines.join("\n")
}
