/**
 * Generator for QueryModels.ts - Type-safe query paths.
 *
 * @since 1.0.0
 */
import type {
  DataModel,
  EntityTypeModel,
  ComplexTypeModel,
  PropertyModel,
  NavigationPropertyModel
} from "../model/DataModel.js"
import {
  getQueryInterfaceName,
  getQueryInstanceName,
  getQueryFactoryName,
  getClassName
} from "./NamingHelper.js"

/**
 * Generate the QueryModels.ts file content.
 *
 * @since 1.0.0
 * @category generation
 */
export const generateQueryModels = (dataModel: DataModel): string => {
  const lines: string[] = []

  // Collect all query path types needed
  const queryPathTypes = collectQueryPathTypes(dataModel)

  // Header
  lines.push(`/**`)
  lines.push(` * Type-safe query paths for ${dataModel.serviceName} entities.`)
  lines.push(` * Generated by odata-effect-gen.`)
  lines.push(` *`)
  lines.push(` * @since 1.0.0`)
  lines.push(` */`)
  lines.push(`import {`)
  lines.push(`  ${Array.from(queryPathTypes).join(",\n  ")},`)
  lines.push(`  createQueryBuilder,`)
  lines.push(`  type QueryBuilder`)
  lines.push(`} from "@odata-effect/odata-effect"`)

  // Import entity types that have entity sets (for QueryBuilder generics)
  const usedEntityNames: string[] = []
  for (const entitySet of dataModel.entitySets.values()) {
    const entityType = dataModel.entityTypes.get(entitySet.entityTypeFqName)
    if (entityType) {
      usedEntityNames.push(entityType.name)
    }
  }
  if (usedEntityNames.length > 0) {
    lines.push(`import type {`)
    lines.push(`  ${usedEntityNames.join(",\n  ")}`)
    lines.push(`} from "./Models.js"`)
  }
  lines.push(``)

  // Generate complex type query paths
  for (const complexType of dataModel.complexTypes.values()) {
    lines.push(...generateQueryInterface(complexType))
    lines.push(``)
    lines.push(...generateQueryInstance(complexType))
    lines.push(``)
  }

  // Generate entity type query paths
  for (const entityType of dataModel.entityTypes.values()) {
    lines.push(...generateQueryInterface(entityType))
    lines.push(``)
    lines.push(...generateQueryInstance(entityType))
    lines.push(``)
  }

  // Generate query builder factories for entity sets
  for (const entitySet of dataModel.entitySets.values()) {
    const entityType = dataModel.entityTypes.get(entitySet.entityTypeFqName)
    if (entityType) {
      lines.push(...generateQueryFactory(entityType))
      lines.push(``)
    }
  }

  return lines.join("\n")
}

/**
 * Collect all query path types used in the model.
 */
const collectQueryPathTypes = (dataModel: DataModel): Set<string> => {
  const types = new Set<string>()

  const addPropertyTypes = (props: ReadonlyArray<PropertyModel>) => {
    for (const prop of props) {
      types.add(prop.typeMapping.queryPath.split("<")[0])
    }
  }

  const addNavPropertyTypes = (navProps: ReadonlyArray<NavigationPropertyModel>) => {
    for (const navProp of navProps) {
      types.add(navProp.isCollection ? "CollectionPath" : "EntityPath")
    }
  }

  for (const complexType of dataModel.complexTypes.values()) {
    addPropertyTypes(complexType.properties)
    addNavPropertyTypes(complexType.navigationProperties)
  }

  for (const entityType of dataModel.entityTypes.values()) {
    addPropertyTypes(entityType.properties)
    addNavPropertyTypes(entityType.navigationProperties)
  }

  return types
}

/**
 * Generate a query interface for a type.
 */
const generateQueryInterface = (
  type: EntityTypeModel | ComplexTypeModel
): string[] => {
  const lines: string[] = []
  const interfaceName = getQueryInterfaceName(type.name)

  lines.push(`/**`)
  lines.push(` * Query paths for ${type.odataName}.`)
  lines.push(` *`)
  lines.push(` * @since 1.0.0`)
  lines.push(` * @category query-paths`)
  lines.push(` */`)
  lines.push(`export interface ${interfaceName} {`)

  for (const prop of type.properties) {
    const basePathType = prop.typeMapping.queryPath
    // If it's a collection of complex/entity types, wrap in CollectionPath
    const pathType = prop.isCollection && basePathType.startsWith("EntityPath<")
      ? basePathType.replace("EntityPath<", "CollectionPath<")
      : basePathType
    lines.push(`  readonly ${prop.name}: ${pathType}`)
  }

  for (const navProp of type.navigationProperties) {
    const targetQName = getQueryInterfaceName(getClassName(navProp.targetType))
    const pathType = navProp.isCollection
      ? `CollectionPath<${targetQName}>`
      : `EntityPath<${targetQName}>`
    lines.push(`  readonly ${navProp.name}: ${pathType}`)
  }

  lines.push(`}`)

  return lines
}

/**
 * Generate a query instance for a type.
 */
const generateQueryInstance = (
  type: EntityTypeModel | ComplexTypeModel
): string[] => {
  const lines: string[] = []
  const interfaceName = getQueryInterfaceName(type.name)
  const instanceName = getQueryInstanceName(type.name)

  lines.push(`/**`)
  lines.push(` * Query paths instance for ${type.odataName}.`)
  lines.push(` *`)
  lines.push(` * @since 1.0.0`)
  lines.push(` * @category query-paths`)
  lines.push(` */`)
  lines.push(`export const ${instanceName}: ${interfaceName} = {`)

  const allFields = [...type.properties, ...type.navigationProperties]
  for (let i = 0; i < type.properties.length; i++) {
    const prop = type.properties[i]
    let pathClass = prop.typeMapping.queryPath.split("<")[0]
    // If it's a collection of complex/entity types, use CollectionPath instead of EntityPath
    if (prop.isCollection && pathClass === "EntityPath") {
      pathClass = "CollectionPath"
    }
    const isLast = i === allFields.length - 1

    // For EntityPath and CollectionPath, we need to provide the nested query paths
    if (pathClass === "EntityPath" || pathClass === "CollectionPath") {
      // Extract the target type from the queryPath generic (e.g., "EntityPath<QAddress>" -> "QAddress")
      const targetMatch = prop.typeMapping.queryPath.match(/<Q(\w+)>/)
      const targetInstanceName = targetMatch ? `q${targetMatch[1]}` : "undefined"
      lines.push(`  ${prop.name}: new ${pathClass}("${prop.odataName}", () => ${targetInstanceName})${isLast ? "" : ","}`)
    } else {
      lines.push(`  ${prop.name}: new ${pathClass}("${prop.odataName}")${isLast ? "" : ","}`)
    }
  }

  for (let i = 0; i < type.navigationProperties.length; i++) {
    const navProp = type.navigationProperties[i]
    const targetInstanceName = getQueryInstanceName(getClassName(navProp.targetType))
    const pathClass = navProp.isCollection ? "CollectionPath" : "EntityPath"
    const isLast = i === type.navigationProperties.length - 1
    lines.push(`  ${navProp.name}: new ${pathClass}("${navProp.odataName}", () => ${targetInstanceName})${isLast ? "" : ","}`)
  }

  lines.push(`}`)

  return lines
}

/**
 * Generate a query builder factory for an entity type.
 */
const generateQueryFactory = (entityType: EntityTypeModel): string[] => {
  const lines: string[] = []
  const interfaceName = getQueryInterfaceName(entityType.name)
  const instanceName = getQueryInstanceName(entityType.name)
  const factoryName = getQueryFactoryName(entityType.name)

  lines.push(`/**`)
  lines.push(` * Creates a type-safe query builder for ${entityType.odataName} entities.`)
  lines.push(` *`)
  lines.push(` * @since 1.0.0`)
  lines.push(` * @category constructors`)
  lines.push(` */`)
  lines.push(`export const ${factoryName} = (): QueryBuilder<${entityType.name}, ${interfaceName}> =>`)
  lines.push(`  createQueryBuilder<${entityType.name}, ${interfaceName}>(${instanceName})`)

  return lines
}
