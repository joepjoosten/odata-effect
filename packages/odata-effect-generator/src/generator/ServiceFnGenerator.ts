/**
 * Generator for entity services using the crud factory.
 *
 * This module generates a single Services.ts file that creates CRUD services
 * for all entity sets using the crud factory from @odata-effect/odata-effect.
 *
 * @since 1.0.0
 */
import type { DataModel, EntitySetModel, EntityTypeModel } from "../model/DataModel.js"
import type { ODataVersion } from "../parser/EdmxSchema.js"
import { getEditableTypeName, getIdTypeName, getServiceClassName } from "./NamingHelper.js"

/**
 * Generated service file.
 *
 * @since 1.0.0
 * @category types
 */
export interface GeneratedServiceFile {
  readonly fileName: string
  readonly content: string
}

/**
 * Result of service generation.
 *
 * @since 1.0.0
 * @category types
 */
export interface ServiceGenerationResult {
  readonly servicesFile: GeneratedServiceFile
}

/**
 * Generate the Services.ts file using crud factory.
 *
 * @since 1.0.0
 * @category generation
 */
export const generateServiceFns = (dataModel: DataModel): ServiceGenerationResult => {
  const content = generateServicesFile(dataModel)
  return {
    servicesFile: {
      fileName: "Services.ts",
      content
    }
  }
}

/**
 * Generate the Services.ts file content.
 */
const generateServicesFile = (dataModel: DataModel): string => {
  const lines: Array<string> = []
  const isV4 = dataModel.version === "V4"
  const crudImportPath = isV4
    ? "@odata-effect/odata-effect/CrudV4"
    : "@odata-effect/odata-effect/Crud"

  // Collect all entity sets with their types
  const entitySets: Array<{
    entitySet: EntitySetModel
    entityType: EntityTypeModel
  }> = []

  for (const entitySet of dataModel.entitySets.values()) {
    const entityType = dataModel.entityTypes.get(entitySet.entityTypeFqName)
    if (entityType) {
      entitySets.push({ entitySet, entityType })
    }
  }

  // Header
  lines.push(`/**`)
  lines.push(` * Entity services for ${dataModel.serviceName} OData ${dataModel.version}.`)
  lines.push(` * Generated by odata-effect-gen.`)
  lines.push(` *`)
  lines.push(` * Uses the crud factory for minimal generated code.`)
  lines.push(` *`)
  lines.push(` * @since 1.0.0`)
  lines.push(` */`)
  lines.push(`import { crud } from "${crudImportPath}"`)
  lines.push(``)

  // Import all entity types
  const modelImports: Array<string> = []
  for (const { entityType } of entitySets) {
    modelImports.push(entityType.name)
    if (entityType.keys.length > 0) {
      modelImports.push(`type ${getIdTypeName(entityType.name)}`)
    }
    modelImports.push(getEditableTypeName(entityType.name))
  }

  lines.push(`import {`)
  for (let i = 0; i < modelImports.length; i++) {
    const isLast = i === modelImports.length - 1
    lines.push(`  ${modelImports[i]}${isLast ? "" : ","}`)
  }
  lines.push(`} from "./Models"`)
  lines.push(``)

  // Re-export types from the crud module
  lines.push(`// Re-export types for convenience`)
  lines.push(`export type { CrudError, CrudContext, CrudService } from "${crudImportPath}"`)
  lines.push(``)

  // Generate each service
  lines.push(`// ============================================================================`)
  lines.push(`// Entity Services`)
  lines.push(`// ============================================================================`)
  lines.push(``)

  for (const { entitySet, entityType } of entitySets) {
    const serviceClassName = getServiceClassName(entitySet.name)
    const entityName = entityType.name
    const editableName = getEditableTypeName(entityName)
    const hasKeys = entityType.keys.length > 0

    lines.push(`/**`)
    lines.push(` * CRUD service for ${entityName} entities.`)
    lines.push(` *`)
    lines.push(` * @since 1.0.0`)
    lines.push(` * @category services`)
    lines.push(` */`)

    if (hasKeys) {
      lines.push(`export const ${serviceClassName} = crud({`)
      lines.push(`  path: "${entitySet.name}",`)
      lines.push(`  schema: ${entityName},`)
      lines.push(`  editableSchema: ${editableName},`)
      lines.push(`  idToKey: ${generateIdToKeyFunction(entityType, dataModel.version)}`)
      lines.push(`})`)
    } else {
      // Entity without keys - can only getAll and create
      lines.push(`export const ${serviceClassName} = crud({`)
      lines.push(`  path: "${entitySet.name}",`)
      lines.push(`  schema: ${entityName},`)
      lines.push(`  editableSchema: ${editableName},`)
      lines.push(`  idToKey: (_id: never) => { throw new Error("Entity has no keys") }`)
      lines.push(`})`)
    }
    lines.push(``)
  }

  return lines.join("\n")
}

/**
 * Generate the idToKey function for an entity type.
 */
const generateIdToKeyFunction = (
  entityType: EntityTypeModel,
  version: ODataVersion
): string => {
  const idTypeName = getIdTypeName(entityType.name)
  const isV4 = version === "V4"

  if (entityType.keys.length === 1) {
    const keyProp = entityType.keys[0]
    const keyTsType = keyProp.typeMapping.tsType
    const primitiveCheck = keyTsType === "number" ? "number" : "string"

    if (isV4) {
      // V4 can use number keys directly
      if (keyTsType === "number") {
        return `(id: ${idTypeName}) => typeof id === "number" ? id : id.${keyProp.name}`
      } else {
        return `(id: ${idTypeName}) => typeof id === "string" ? { ${keyProp.odataName}: id } : { ${keyProp.odataName}: id.${keyProp.name} }`
      }
    } else {
      // V2 needs string keys
      return `(id: ${idTypeName}) => typeof id === "${primitiveCheck}" ? { ${keyProp.odataName}: String(id) } : { ${keyProp.odataName}: String(id.${keyProp.name}) }`
    }
  } else {
    // Composite key
    const keyMapping = entityType.keys.map((k) => {
      if (isV4) {
        return `${k.odataName}: id.${k.name}`
      } else {
        return `${k.odataName}: String(id.${k.name})`
      }
    }).join(", ")

    return `(id: ${idTypeName}) => ({ ${keyMapping} })`
  }
}
