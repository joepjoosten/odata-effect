/**
 * Generator for Models.ts - Effect Schema definitions.
 *
 * @since 1.0.0
 */
import type {
  ComplexTypeModel,
  DataModel,
  EntityTypeModel,
  EnumTypeModel,
  NavigationPropertyModel,
  PropertyModel
} from "../model/DataModel.js"
import { getClassName, getEditableTypeName, getIdTypeName } from "./NamingHelper.js"

/**
 * Get dependencies for a type (complex types it references via properties or baseType).
 */
const getTypeDependencies = (
  type: ComplexTypeModel | EntityTypeModel,
  allComplexTypes: Set<string>,
  allEntityTypes: Set<string>
): Set<string> => {
  const deps = new Set<string>()

  // Add base type dependency if it exists
  if (type.baseType) {
    const baseTypeName = getClassName(type.baseType.split(".").pop() ?? type.baseType)
    if (allComplexTypes.has(baseTypeName) || allEntityTypes.has(baseTypeName)) {
      deps.add(baseTypeName)
    }
  }

  // Add property type dependencies (for complex types referenced in properties)
  for (const prop of type.properties) {
    const propTypeName = prop.typeMapping.effectSchema
    if (allComplexTypes.has(propTypeName)) {
      deps.add(propTypeName)
    }
  }

  return deps
}

/**
 * Topologically sort types based on their dependencies.
 */
const sortTypesByDependency = <T extends ComplexTypeModel | EntityTypeModel>(
  types: Array<T>,
  allComplexTypes: Set<string>,
  allEntityTypes: Set<string>
): Array<T> => {
  const sorted: Array<T> = []
  const visited = new Set<string>()
  const visiting = new Set<string>()

  const visit = (type: T) => {
    if (visited.has(type.name)) return
    if (visiting.has(type.name)) {
      // Circular dependency - just add it
      visited.add(type.name)
      sorted.push(type)
      return
    }

    visiting.add(type.name)

    const deps = getTypeDependencies(type, allComplexTypes, allEntityTypes)
    for (const depName of deps) {
      const depType = types.find((t) => t.name === depName)
      if (depType && !visited.has(depName)) {
        visit(depType)
      }
    }

    visiting.delete(type.name)
    visited.add(type.name)
    sorted.push(type)
  }

  for (const type of types) {
    visit(type)
  }

  return sorted
}

/**
 * Check if any property uses ODataSchema types.
 */
const needsODataSchemaImport = (dataModel: DataModel): boolean => {
  const checkProperties = (properties: ReadonlyArray<PropertyModel>): boolean =>
    properties.some((p) => p.typeMapping.effectSchema.startsWith("ODataSchema."))

  for (const type of dataModel.entityTypes.values()) {
    if (checkProperties(type.properties)) return true
  }
  for (const type of dataModel.complexTypes.values()) {
    if (checkProperties(type.properties)) return true
  }
  return false
}

/**
 * Check which Effect type imports are needed based on tsType usage.
 */
const getNeededEffectTypeImports = (dataModel: DataModel): Set<string> => {
  const needed = new Set<string>()

  const checkTsType = (tsType: string): void => {
    if (tsType.startsWith("DateTime.")) needed.add("DateTime")
    if (tsType.startsWith("BigDecimal.")) needed.add("BigDecimal")
    if (tsType.startsWith("Duration.")) needed.add("Duration")
  }

  for (const type of dataModel.entityTypes.values()) {
    for (const prop of type.properties) {
      checkTsType(prop.typeMapping.tsType)
    }
  }
  for (const type of dataModel.complexTypes.values()) {
    for (const prop of type.properties) {
      checkTsType(prop.typeMapping.tsType)
    }
  }

  return needed
}

/**
 * Generate the Models.ts file content.
 *
 * @since 1.0.0
 * @category generation
 */
export const generateModels = (dataModel: DataModel): string => {
  const lines: Array<string> = []

  // Collect all type names for dependency resolution
  const allComplexTypes = new Set(Array.from(dataModel.complexTypes.values()).map((t) => t.name))
  const allEntityTypes = new Set(Array.from(dataModel.entityTypes.values()).map((t) => t.name))

  // Header
  lines.push(`/**`)
  lines.push(` * Effect Schema models for ${dataModel.serviceName} OData service.`)
  lines.push(` * Generated by odata-effect-gen.`)
  lines.push(` *`)
  lines.push(` * @since 1.0.0`)
  lines.push(` */`)
  lines.push(`import * as Schema from "effect/Schema"`)

  // Add Effect type imports if needed (for DateTime, BigDecimal, Duration)
  const effectTypeImports = getNeededEffectTypeImports(dataModel)
  for (const effectType of effectTypeImports) {
    lines.push(`import type * as ${effectType} from "effect/${effectType}"`)
  }

  // Add ODataSchema import if needed
  if (needsODataSchemaImport(dataModel)) {
    lines.push(`import { ODataSchema } from "@odata-effect/odata-effect"`)
  }

  lines.push(``)

  // Generate enum types (no dependencies, always first)
  for (const enumType of dataModel.enumTypes.values()) {
    for (const line of generateEnumType(enumType)) lines.push(line)
    lines.push(``)
  }

  // Generate complex types in dependency order
  const sortedComplexTypes = sortTypesByDependency(
    Array.from(dataModel.complexTypes.values()),
    allComplexTypes,
    allEntityTypes
  )
  for (const complexType of sortedComplexTypes) {
    for (const line of generateComplexType(complexType, dataModel)) lines.push(line)
    lines.push(``)
  }

  // Generate entity types in dependency order
  const sortedEntityTypes = sortTypesByDependency(
    Array.from(dataModel.entityTypes.values()),
    allComplexTypes,
    allEntityTypes
  )
  for (const entityType of sortedEntityTypes) {
    for (const line of generateEntityType(entityType, dataModel)) lines.push(line)
    lines.push(``)
  }

  return lines.join("\n")
}

/**
 * Generate an enum type.
 */
const generateEnumType = (enumType: EnumTypeModel): Array<string> => {
  const lines: Array<string> = []
  const members = enumType.members.map((m) => `"${m.name}"`).join(", ")

  lines.push(`/**`)
  lines.push(` * ${enumType.odataName} enum type.`)
  lines.push(` *`)
  lines.push(` * @since 1.0.0`)
  lines.push(` * @category enums`)
  lines.push(` */`)
  lines.push(`export const ${enumType.name} = Schema.Literal(${members})`)
  lines.push(`export type ${enumType.name} = Schema.Schema.Type<typeof ${enumType.name}>`)

  return lines
}

/**
 * Generate a complex type.
 */
const generateComplexType = (
  complexType: ComplexTypeModel,
  dataModel: DataModel
): Array<string> => {
  const lines: Array<string> = []

  lines.push(`/**`)
  lines.push(` * ${complexType.odataName} complex type.`)
  lines.push(` *`)
  lines.push(` * @since 1.0.0`)
  lines.push(` * @category models`)
  lines.push(` */`)

  const fields = generateSchemaFields(complexType.properties, complexType.navigationProperties, dataModel)

  lines.push(`export class ${complexType.name} extends Schema.Class<${complexType.name}>("${complexType.name}")({`)
  for (const f of fields) lines.push(`  ${f}`)
  lines.push(`}) {}`)

  // Generate editable type
  lines.push(``)
  lines.push(`/**`)
  lines.push(` * Editable ${complexType.odataName} for creating/updating operations.`)
  lines.push(` *`)
  lines.push(` * @since 1.0.0`)
  lines.push(` * @category models`)
  lines.push(` */`)

  const editableFields = generateEditableSchemaFields(complexType.properties)
  const editableName = getEditableTypeName(complexType.name)

  lines.push(`export const ${editableName} = Schema.Struct({`)
  for (const f of editableFields) lines.push(`  ${f}`)
  lines.push(`})`)
  lines.push(`export type ${editableName} = Schema.Schema.Type<typeof ${editableName}>`)

  return lines
}

/**
 * Generate an entity type with ID and editable variants.
 */
const generateEntityType = (
  entityType: EntityTypeModel,
  dataModel: DataModel
): Array<string> => {
  const lines: Array<string> = []

  // Main entity class
  lines.push(`/**`)
  lines.push(` * ${entityType.odataName} entity type.`)
  lines.push(` *`)
  lines.push(` * @since 1.0.0`)
  lines.push(` * @category models`)
  lines.push(` */`)

  const fields = generateSchemaFields(entityType.properties, entityType.navigationProperties, dataModel)

  lines.push(`export class ${entityType.name} extends Schema.Class<${entityType.name}>("${entityType.name}")({`)
  for (const f of fields) lines.push(`  ${f}`)
  lines.push(`}) {}`)

  // ID type
  if (entityType.keys.length > 0) {
    lines.push(``)
    lines.push(`/**`)
    lines.push(` * ${entityType.odataName} ID type.`)
    lines.push(` *`)
    lines.push(` * @since 1.0.0`)
    lines.push(` * @category models`)
    lines.push(` */`)

    const idTypeName = getIdTypeName(entityType.name)

    if (entityType.keys.length === 1) {
      const key = entityType.keys[0]
      const keySchema = getPropertySchemaType(key, false)
      lines.push(`export const ${idTypeName} = Schema.Union(`)
      lines.push(`  ${keySchema},`)
      lines.push(`  Schema.Struct({ ${key.name}: ${keySchema} })`)
      lines.push(`)`)
    } else {
      // Composite key - only struct form makes sense
      const keyFields = entityType.keys.map((k) => {
        const schema = getPropertySchemaType(k, false)
        return `${k.name}: ${schema}`
      })
      lines.push(`export const ${idTypeName} = Schema.Struct({ ${keyFields.join(", ")} })`)
    }
    lines.push(`export type ${idTypeName} = Schema.Schema.Type<typeof ${idTypeName}>`)
  }

  // Editable type
  lines.push(``)
  lines.push(`/**`)
  lines.push(` * Editable ${entityType.odataName} for creating/updating operations.`)
  lines.push(` *`)
  lines.push(` * @since 1.0.0`)
  lines.push(` * @category models`)
  lines.push(` */`)

  const editableFields = generateEditableSchemaFields(
    entityType.properties.filter((p) => !p.isKey)
  )
  const editableName = getEditableTypeName(entityType.name)

  lines.push(`export const ${editableName} = Schema.Struct({`)
  for (const f of editableFields) lines.push(`  ${f}`)
  lines.push(`})`)
  lines.push(`export type ${editableName} = Schema.Schema.Type<typeof ${editableName}>`)

  return lines
}

/**
 * Generate schema field definitions for a class.
 * Note: Navigation properties are excluded to avoid circular reference issues.
 * They can be loaded via $expand queries.
 */
const generateSchemaFields = (
  properties: ReadonlyArray<PropertyModel>,
  _navigationProperties: ReadonlyArray<NavigationPropertyModel>,
  _dataModel: DataModel
): Array<string> => {
  const fields: Array<string> = []

  for (let i = 0; i < properties.length; i++) {
    const prop = properties[i]
    const schemaType = getPropertySchemaType(prop, prop.isNullable && !prop.isKey)
    const isLast = i === properties.length - 1
    const fieldDef = getPropertyFieldDefinition(prop, schemaType)
    fields.push(`${fieldDef}${isLast ? "" : ","}`)
  }

  // Navigation properties are intentionally excluded from Schema.Class
  // to avoid circular reference issues. They can be loaded via $expand.

  return fields
}

/**
 * Generate schema field definitions for an editable struct.
 */
const generateEditableSchemaFields = (
  properties: ReadonlyArray<PropertyModel>
): Array<string> => {
  const fields: Array<string> = []

  for (let i = 0; i < properties.length; i++) {
    const prop = properties[i]
    const schemaType = getPropertySchemaType(prop, prop.isNullable)
    const isLast = i === properties.length - 1
    const fieldDef = getPropertyFieldDefinition(prop, schemaType)
    fields.push(`${fieldDef}${isLast ? "" : ","}`)
  }

  return fields
}

/**
 * Get a complete property field definition including fromKey mapping if needed.
 *
 * When the OData property name differs from the TypeScript property name,
 * we use Schema.propertySignature with Schema.fromKey to map between them.
 * This is essential for OData V2 responses which use PascalCase property names.
 *
 * @example
 * // When odataName == name:
 * name: Schema.String
 *
 * // When odataName ("ID") != name ("id"):
 * id: Schema.propertySignature(Schema.Number).pipe(Schema.fromKey("ID"))
 */
const getPropertyFieldDefinition = (
  prop: PropertyModel,
  schemaType: string
): string => {
  // If OData name matches TypeScript name, use simple format
  if (prop.odataName === prop.name) {
    return `${prop.name}: ${schemaType}`
  }

  // Use propertySignature with fromKey to map between encoded (OData) and decoded (TypeScript) names
  return `${prop.name}: Schema.propertySignature(${schemaType}).pipe(Schema.fromKey("${prop.odataName}"))`
}

/**
 * Get the Schema type for a property.
 */
const getPropertySchemaType = (
  prop: PropertyModel,
  makeOptional: boolean
): string => {
  let baseType = prop.typeMapping.effectSchema

  // Handle collection
  if (prop.isCollection) {
    baseType = `Schema.Array(${baseType})`
  }

  // Handle nullable/optional
  if (makeOptional) {
    return `Schema.optionalWith(${baseType}, { nullable: true })`
  }

  return baseType
}
